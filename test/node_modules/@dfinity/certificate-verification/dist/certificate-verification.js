import { Certificate as u, Cbor as d, reconstruct as m, compare as h } from "@dfinity/agent";
import { lebDecode as l, PipeArrayBuffer as w } from "@dfinity/candid";
class n extends Error {
  constructor(t) {
    super(t), this.name = this.constructor.name;
  }
}
class f extends Error {
  constructor(t) {
    super(t), this.name = this.constructor.name;
  }
}
async function E({
  canisterId: e,
  encodedCertificate: t,
  encodedTree: r,
  rootKey: c,
  maxCertificateTimeOffsetMs: i
}) {
  const s = Date.now(), o = await u.create({
    certificate: t,
    canisterId: e,
    rootKey: c
  }), a = d.decode(r);
  return p(o, i, s), await C(a, o, e), a;
}
function p(e, t, r) {
  const c = l(
    new w(e.lookup(["time"]))
  ), i = Number(c / BigInt(1e6));
  if (i - t > r)
    throw new f(
      `Invalid certificate: time ${i} is too far in the future (current time: ${r})`
    );
  if (i + t < r)
    throw new f(
      `Invalid certificate: time ${i} is too far in the past (current time: ${r})`
    );
}
async function C(e, t, r) {
  const c = await m(e), i = t.lookup([
    "canister",
    r.toUint8Array(),
    "certified_data"
  ]);
  if (!i)
    throw new n(
      "Could not find certified data in the certificate."
    );
  if (!v(i, c))
    throw new n(
      "Tree root hash did not match the certified data in the certificate."
    );
}
function v(e, t) {
  return h(e, t) === 0;
}
export {
  E as verifyCertification
};
//# sourceMappingURL=certificate-verification.js.map
