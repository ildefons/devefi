(function(r,n){typeof exports=="object"&&typeof module<"u"?n(exports,require("@dfinity/agent"),require("@dfinity/candid")):typeof define=="function"&&define.amd?define(["exports","@dfinity/agent","@dfinity/candid"],n):(r=typeof globalThis<"u"?globalThis:r||self,n(r["@dfinity/certificate-verification"]={},r["dfinity-agent"],r["dfinity-candid"]))})(this,function(r,n,a){"use strict";class f extends Error{constructor(e){super(e),this.name=this.constructor.name}}class d extends Error{constructor(e){super(e),this.name=this.constructor.name}}async function h({canisterId:t,encodedCertificate:e,encodedTree:c,rootKey:o,maxCertificateTimeOffsetMs:i}){const l=Date.now(),s=await n.Certificate.create({certificate:e,canisterId:t,rootKey:o}),u=n.Cbor.decode(c);return m(s,i,l),await y(u,s,t),u}function m(t,e,c){const o=a.lebDecode(new a.PipeArrayBuffer(t.lookup(["time"]))),i=Number(o/BigInt(1e6));if(i-e>c)throw new d(`Invalid certificate: time ${i} is too far in the future (current time: ${c})`);if(i+e<c)throw new d(`Invalid certificate: time ${i} is too far in the past (current time: ${c})`)}async function y(t,e,c){const o=await n.reconstruct(t),i=e.lookup(["canister",c.toUint8Array(),"certified_data"]);if(!i)throw new f("Could not find certified data in the certificate.");if(!p(i,o))throw new f("Tree root hash did not match the certified data in the certificate.")}function p(t,e){return n.compare(t,e)===0}r.verifyCertification=h,Object.defineProperty(r,Symbol.toStringTag,{value:"Module"})});
//# sourceMappingURL=certificate-verification.umd.cjs.map
